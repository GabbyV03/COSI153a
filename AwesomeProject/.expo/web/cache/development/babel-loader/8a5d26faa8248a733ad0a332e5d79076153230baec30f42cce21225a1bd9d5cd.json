{"ast":null,"code":"import { useDerivedValue, withSpring } from \"react-native-reanimated\";\nimport { useAnimatedValues } from \"../context/animatedValueContext\";\nimport { useDraggableFlatListContext } from \"../context/draggableFlatListContext\";\nimport { useRefs } from \"../context/refContext\";\nexport function useCellTranslate(_ref) {\n  var cellIndex = _ref.cellIndex,\n    cellSize = _ref.cellSize,\n    cellOffset = _ref.cellOffset;\n  var _useAnimatedValues = useAnimatedValues(),\n    activeIndexAnim = _useAnimatedValues.activeIndexAnim,\n    activeCellSize = _useAnimatedValues.activeCellSize,\n    hoverOffset = _useAnimatedValues.hoverOffset,\n    spacerIndexAnim = _useAnimatedValues.spacerIndexAnim,\n    placeholderOffset = _useAnimatedValues.placeholderOffset,\n    hoverAnim = _useAnimatedValues.hoverAnim,\n    viewableIndexMin = _useAnimatedValues.viewableIndexMin,\n    viewableIndexMax = _useAnimatedValues.viewableIndexMax;\n  var _useDraggableFlatList = useDraggableFlatListContext(),\n    activeKey = _useDraggableFlatList.activeKey;\n  var _useRefs = useRefs(),\n    animationConfigRef = _useRefs.animationConfigRef;\n  var translate = useDerivedValue(function () {\n    var isActiveCell = cellIndex === activeIndexAnim.value;\n    var isOutsideViewableRange = !isActiveCell && (cellIndex < viewableIndexMin.value || cellIndex > viewableIndexMax.value);\n    if (!activeKey || activeIndexAnim.value < 0 || isOutsideViewableRange) {\n      return 0;\n    }\n    var isBeforeActive = cellIndex < activeIndexAnim.value;\n    var isAfterActive = cellIndex > activeIndexAnim.value;\n    var hoverPlusActiveSize = hoverOffset.value + activeCellSize.value;\n    var offsetPlusHalfSize = cellOffset.value + cellSize.value / 2;\n    var offsetPlusSize = cellOffset.value + cellSize.value;\n    var result = -1;\n    if (isAfterActive) {\n      if (hoverPlusActiveSize >= cellOffset.value && hoverPlusActiveSize < offsetPlusHalfSize) {\n        result = cellIndex - 1;\n      } else if (hoverPlusActiveSize >= offsetPlusHalfSize && hoverPlusActiveSize < offsetPlusSize) {\n        result = cellIndex;\n      }\n    } else if (isBeforeActive) {\n      if (hoverOffset.value < offsetPlusSize && hoverOffset.value >= offsetPlusHalfSize) {\n        result = cellIndex + 1;\n      } else if (hoverOffset.value >= cellOffset.value && hoverOffset.value < offsetPlusHalfSize) {\n        result = cellIndex;\n      }\n    }\n    if (result !== -1 && result !== spacerIndexAnim.value) {\n      spacerIndexAnim.value = result;\n    }\n    if (spacerIndexAnim.value === cellIndex) {\n      var newPlaceholderOffset = isAfterActive ? cellSize.value + (cellOffset.value - activeCellSize.value) : cellOffset.value;\n      placeholderOffset.value = newPlaceholderOffset;\n    }\n    if (isActiveCell) {\n      return hoverAnim.value;\n    }\n    var shouldTranslate = isAfterActive ? cellIndex <= spacerIndexAnim.value : cellIndex >= spacerIndexAnim.value;\n    var translationAmt = shouldTranslate ? activeCellSize.value * (isAfterActive ? -1 : 1) : 0;\n    return withSpring(translationAmt, animationConfigRef.current);\n  }, [activeKey, cellIndex]);\n  return translate;\n}","map":{"version":3,"names":["useDerivedValue","withSpring","useAnimatedValues","useDraggableFlatListContext","useRefs","useCellTranslate","_ref","cellIndex","cellSize","cellOffset","_useAnimatedValues","activeIndexAnim","activeCellSize","hoverOffset","spacerIndexAnim","placeholderOffset","hoverAnim","viewableIndexMin","viewableIndexMax","_useDraggableFlatList","activeKey","_useRefs","animationConfigRef","translate","isActiveCell","value","isOutsideViewableRange","isBeforeActive","isAfterActive","hoverPlusActiveSize","offsetPlusHalfSize","offsetPlusSize","result","newPlaceholderOffset","shouldTranslate","translationAmt","current"],"sources":["/Users/gabriellavukomanovic/Desktop/Summer2023/AwesomeProject/node_modules/react-native-draggable-flatlist/lib/module/hooks/useCellTranslate.tsx"],"sourcesContent":["import Animated, { useDerivedValue, withSpring } from \"react-native-reanimated\";\nimport { useAnimatedValues } from \"../context/animatedValueContext\";\nimport { useDraggableFlatListContext } from \"../context/draggableFlatListContext\";\nimport { useRefs } from \"../context/refContext\";\n\ntype Params = {\n  cellIndex: number;\n  cellSize: Animated.SharedValue<number>;\n  cellOffset: Animated.SharedValue<number>;\n};\n\nexport function useCellTranslate({ cellIndex, cellSize, cellOffset }: Params) {\n  const {\n    activeIndexAnim,\n    activeCellSize,\n    hoverOffset,\n    spacerIndexAnim,\n    placeholderOffset,\n    hoverAnim,\n    viewableIndexMin,\n    viewableIndexMax,\n  } = useAnimatedValues();\n\n  const { activeKey } = useDraggableFlatListContext();\n\n  const { animationConfigRef } = useRefs();\n\n  const translate = useDerivedValue(() => {\n    const isActiveCell = cellIndex === activeIndexAnim.value;\n    const isOutsideViewableRange =\n      !isActiveCell &&\n      (cellIndex < viewableIndexMin.value ||\n        cellIndex > viewableIndexMax.value);\n    if (!activeKey || activeIndexAnim.value < 0 || isOutsideViewableRange) {\n      return 0;\n    }\n\n    // Determining spacer index is hard to visualize. See diagram: https://i.imgur.com/jRPf5t3.jpg\n    const isBeforeActive = cellIndex < activeIndexAnim.value;\n    const isAfterActive = cellIndex > activeIndexAnim.value;\n\n    const hoverPlusActiveSize = hoverOffset.value + activeCellSize.value;\n    const offsetPlusHalfSize = cellOffset.value + cellSize.value / 2;\n    const offsetPlusSize = cellOffset.value + cellSize.value;\n    let result = -1;\n\n    if (isAfterActive) {\n      if (\n        hoverPlusActiveSize >= cellOffset.value &&\n        hoverPlusActiveSize < offsetPlusHalfSize\n      ) {\n        // bottom edge of active cell overlaps top half of current cell\n        result = cellIndex - 1;\n      } else if (\n        hoverPlusActiveSize >= offsetPlusHalfSize &&\n        hoverPlusActiveSize < offsetPlusSize\n      ) {\n        // bottom edge of active cell overlaps bottom half of current cell\n        result = cellIndex;\n      }\n    } else if (isBeforeActive) {\n      if (\n        hoverOffset.value < offsetPlusSize &&\n        hoverOffset.value >= offsetPlusHalfSize\n      ) {\n        // top edge of active cell overlaps bottom half of current cell\n        result = cellIndex + 1;\n      } else if (\n        hoverOffset.value >= cellOffset.value &&\n        hoverOffset.value < offsetPlusHalfSize\n      ) {\n        // top edge of active cell overlaps top half of current cell\n        result = cellIndex;\n      }\n    }\n\n    if (result !== -1 && result !== spacerIndexAnim.value) {\n      spacerIndexAnim.value = result;\n    }\n\n    if (spacerIndexAnim.value === cellIndex) {\n      const newPlaceholderOffset = isAfterActive\n        ? cellSize.value + (cellOffset.value - activeCellSize.value)\n        : cellOffset.value;\n      placeholderOffset.value = newPlaceholderOffset;\n    }\n\n    // Active cell follows touch\n    if (isActiveCell) {\n      return hoverAnim.value;\n    }\n\n    // Translate cell down if it is before active index and active cell has passed it.\n    // Translate cell up if it is after the active index and active cell has passed it.\n\n    const shouldTranslate = isAfterActive\n      ? cellIndex <= spacerIndexAnim.value\n      : cellIndex >= spacerIndexAnim.value;\n\n    const translationAmt = shouldTranslate\n      ? activeCellSize.value * (isAfterActive ? -1 : 1)\n      : 0;\n\n    return withSpring(translationAmt, animationConfigRef.current);\n  }, [activeKey, cellIndex]);\n\n  return translate;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}